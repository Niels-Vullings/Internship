---
title: "RSTS - Comparing Triads"
author: "Vullings, Niels"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
rm(list=ls())
```

```{r}
library(RSiena)
library(foreach)
library(sna)
library(iterators)
library(doParallel)

```

# Prototype
```{r}
ftriads <- function(net) {
  
  if(ncol(net) < 3 & nrow(net) < 3){
    print(isTRUE(ncol(net) < 3 & nrow(net) < 3))
    print("warning: Matrix does not contain triads")
  } else{
    x <-
      foreach(a1=1:nrow(net), i=icount() , .combine="rbind") %:%
      foreach(a2=1:nrow(net), j=icount() , .combine="rbind") %:%
      foreach(a3=1:nrow(net),  k=icount() , .combine="rbind") %do% {
        if (i>=j & j>=k ) data.frame(i=i, j=j, k=k, sna::triad.census(net[c(a1,a2,a3),c(a1,a2,a3)])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
      }
    triads <<-  x
    print(as.matrix(colSums(x[4:19])))
    # return(x)
  }
}

triad.evo <- function(net) {
  
  if(ncol(net) < 3 & nrow(net) < 3){
    print(isTRUE(ncol(net) < 3 & nrow(net) < 3))
    print("warning: Matrix does not contain triads")
  } else{
    x <-
      foreach(a1=1:nrow(net), i=icount() , .combine="rbind") %:%
      foreach(a2=1:nrow(net), j=icount() , .combine="rbind") %:%
      foreach(a3=1:nrow(net),  k=icount() , .combine="rbind") %do% {
        if (i>j & j>k ) data.frame(i=i, j=j, k=k, count=sna::triad.census(net[c(a1,a2,a3),c(a1,a2,a3)])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
      }
    triad <<-  x
    print(as.matrix(colSums(x[4:19])))
    # return(x)
  }
}


# sna::triad.census(s501[1:3,1:3])

#langzaam, dus slechts op deel
# ftriads(s501[1:5,1:5]) #With repititions
# triad.evo(s501[1:5,1:5]) #Without repititions


```


# First version
```{r}
triad.evolution <- function(t1,t2="def") { #Function no displays macro changes between t1 and t2, but no point of departure change
  
  xt1 <-
    foreach(a1=1:nrow(t1), i=icount() , .combine="rbind") %:%
    foreach(a2=1:nrow(t1), j=icount() , .combine="rbind") %:%
    foreach(a3=1:nrow(t1),  k=icount() , .combine="rbind") %do% {
      if (i>j & j>k ) data.frame(i=i, j=j, k=k, sna::triad.census(t1[c(a1,a2,a3),c(a1,a2,a3)])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
    }
  print(xt1)
  xt1$stamp <- "t1"
  xt1$name <- paste0(xt1$i,xt1$j,xt1$k)
  xt1 <- subset(xt1, select=c(name,stamp,X003,X012,X102,X021D,X021U,X021C,X111D,X111U,X030T,X030C,X201,X120D,X120U,X120C,X210,X300))
  
  for(i in 1:nrow(xt1)){
    xt1$typeT1[i] <- colnames(xt1[which(xt1[i,] == 1)])#return the triad class for each triad
    
  }
  
  xt2 <-
    foreach(a1=1:nrow(t2), i=icount() , .combine="rbind") %:%
    foreach(a2=1:nrow(t2), j=icount() , .combine="rbind") %:%
    foreach(a3=1:nrow(t2),  k=icount() , .combine="rbind") %do% {
      if (i>j & j>k ) data.frame(i=i, j=j, k=k, sna::triad.census(t2[c(a1,a2,a3),c(a1,a2,a3)])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
    }
  print(xt2)
  xt2$stamp <- "t2"
  xt2$name <- paste0(xt2$i,xt2$j,xt2$k)
  xt2 <- subset(xt2, select=c(name,stamp,X003,X012,X102,X021D,X021U,X021C,X111D,X111U,X030T,X030C,X201,X120D,X120U,X120C,X210,X300))
  
  for(i in 1:nrow(xt2)){
    xt2$typeT2[i] <- colnames(xt2[which(xt2[i,] == 1)])#return the triad class for a specific triad
    
  }
  
  test <<- merge.data.frame(subset(xt1, select=c(name,typeT1)),subset(xt2,select=c(name,typeT2)), by = "name")
  # triadst2 <<-  xt2
  # triadst1 <<-  xt1
  # print(as.matrix(colSums(xt2[4:19])))
  # print(as.matrix(colSums(xt1[4:19])))
  # print(as.matrix(colSums(xt2[3:18])-colSums(xt1[3:18])))
  # return(x)
}

```



```{r}
# t1 <- s501[1:4,1:4]
# t2 <- s502[1:4,1:4]
# timestamp()
# triad.evolution(s501[1:5,1:5],s502[1:5,1:5])
# timestamp()

```

```{r}
# if (i>j & j>k ) data.frame(i=i, j=j, k=k,
#                            ij=as.character(t1[a1,a2]), ji=as.character(t1[a2,a1]),
#                            ik=as.character(t1[a1,a3]),ki=as.character(t1[a3,a1]),
#                            jk=as.character(t1[a2,a3]),kj=as.character(t1[a3,a2]),
#                            count=sna::triad.census(t1[c(a1,a2,a3),c(a1,a2,a3) ])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
# }

```


# Second version
```{r}
triad.evolution2 <- function(t1,t2="def") { #Function no displays macro changes between t1 and t2, but no point of departure change
  
  xt1 <-
    foreach(a1=1:nrow(t1), i=icount() , .combine="rbind") %:%
    foreach(a2=1:nrow(t1), j=icount() , .combine="rbind") %:%
    foreach(a3=1:nrow(t1),  k=icount() , .combine="rbind") %do% {
      if (i>j & j>k ) data.frame(i=i, j=j, k=k,
                                 t1_ij=as.character(t1[a1,a2]), t1_ji=as.character(t1[a2,a1]),
                                 t1_ik=as.character(t1[a1,a3]),t1_ki=as.character(t1[a3,a1]),
                                 t1_jk=as.character(t1[a2,a3]),t1_kj=as.character(t1[a3,a2]),
                                 sna::triad.census(t1[c(a1,a2,a3),c(a1,a2,a3) ])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
    }
  
  # print(xt1)
  
  xt1$stamp <- "t1"
  xt1$name <- paste0(xt1$i,".",xt1$j,".",xt1$k)
  t1 <- subset(xt1, select=c(name,stamp, t1_ij:t1_kj))
  xt1 <- subset(xt1, select=c(name,stamp,X003,X012,X102,X021D,X021U,X021C,X111D,X111U,X030T,X030C,X201,X120D,X120U,X120C,X210,X300))
  
  for(i in 1:nrow(xt1)){
    t1$typeT1[i] <- colnames(xt1[which(xt1[i,] == 1)])#return the triad class for each triad
    
  }
  
  # print(t1)
  
  xt2 <-
    foreach(a1=1:nrow(t2), i=icount() , .combine="rbind") %:%
    foreach(a2=1:nrow(t2), j=icount() , .combine="rbind") %:%
    foreach(a3=1:nrow(t2),  k=icount() , .combine="rbind") %do% {
      if (i>j & j>k ) data.frame(i=i, j=j, k=k,
                                 t2_ij=as.character(t2[a1,a2]), t2_ji=as.character(t2[a2,a1]),
                                 t2_ik=as.character(t2[a1,a3]),t2_ki=as.character(t2[a3,a1]),
                                 t2_jk=as.character(t2[a2,a3]),t2_kj=as.character(t2[a3,a2]),
                                 sna::triad.census(t2[c(a1,a2,a3),c(a1,a2,a3) ])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
    }
  
  # print(xt2)
  
  xt2$stamp <- "t2"
  xt2$name <- paste0(xt2$i,".",xt2$j,".",xt2$k)
  t2 <- subset(xt2, select=c(name,stamp, t2_ij:t2_kj))
  xt2 <- subset(xt2, select=c(name,stamp,X003,X012,X102,X021D,X021U,X021C,X111D,X111U,X030T,X030C,X201,X120D,X120U,X120C,X210,X300))
  
  
  for(i in 1:nrow(xt2)){
    t2$typeT2[i] <- colnames(xt2[which(xt2[i,] == 1)])#return the triad class for a specific triad
    
  }
  # print(t2)
  Triad_change <<- merge.data.frame((t1),subset(t2,select=c(name, stamp, t2_ij:t2_kj, typeT2)), by = "name")
  
  
}
```

```{r}
# triad.evolution2(s501[1:10,1:10],s502[1:10,1:10])

```

# Third version
```{r}
triad.evolution3 <- function(t1,t2) { #Function no displays macro changes between t1 and t2, but no point of departure change
  
  xt1 <-
    foreach(a1=1:nrow(t1), i=icount() , .combine="rbind") %:%
    foreach(a2=1:nrow(t1), j=icount() , .combine="rbind") %:%
    foreach(a3=1:nrow(t1),  k=icount() , .combine="rbind") %do% {
      if (i>j & j>k ) data.frame(i=i, j=j, k=k,
                                 t1_ij=as.character(t1[a1,a2]), t1_ji=as.character(t1[a2,a1]),
                                 t1_ik=as.character(t1[a1,a3]),t1_ki=as.character(t1[a3,a1]),
                                 t1_jk=as.character(t1[a2,a3]),t1_kj=as.character(t1[a3,a2]),
                                 sna::triad.census(t1[c(a1,a2,a3),c(a1,a2,a3) ])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
    }
  
  # print(xt1)
  
  xt1$stamp <- "t1"
  xt1$name <- paste0(xt1$i,".",xt1$j,".",xt1$k)
  t1 <- subset(xt1, select=c(name,stamp, t1_ij:t1_kj))
  xt1 <- subset(xt1, select=c(name,stamp,X003,X012,X102,X021D,X021U,X021C,X111D,X111U,X030T,X030C,X201,X120D,X120U,X120C,X210,X300))
  
  for(i in 1:nrow(xt1)){
    t1$typeT1[i] <- colnames(xt1[which(xt1[i,] == 1)])#return the triad class for each triad
    
  }
  
  # print(t1)
  
  xt2 <-
    foreach(a1=1:nrow(t2), i=icount() , .combine="rbind") %:%
    foreach(a2=1:nrow(t2), j=icount() , .combine="rbind") %:%
    foreach(a3=1:nrow(t2),  k=icount() , .combine="rbind") %do% {
      if (i>j & j>k ) data.frame(i=i, j=j, k=k,
                                 t2_ij=as.character(t2[a1,a2]), t2_ji=as.character(t2[a2,a1]),
                                 t2_ik=as.character(t2[a1,a3]),t2_ki=as.character(t2[a3,a1]),
                                 t2_jk=as.character(t2[a2,a3]),t2_kj=as.character(t2[a3,a2]),
                                 sna::triad.census(t2[c(a1,a2,a3),c(a1,a2,a3) ])) #(i>j & j>k ) determines with or without repititions [current = NO REP]
    }
  
  # print(xt2)
  
  xt2$stamp <- "t2"
  xt2$name <- paste0(xt2$i,".",xt2$j,".",xt2$k)
  t2 <- subset(xt2, select=c(name,stamp, t2_ij:t2_kj))
  xt2 <- subset(xt2, select=c(name,stamp,X003,X012,X102,X021D,X021U,X021C,X111D,X111U,X030T,X030C,X201,X120D,X120U,X120C,X210,X300))
  
  
  for(i in 1:nrow(xt2)){
    t2$typeT2[i] <- colnames(xt2[which(xt2[i,] == 1)])#return the triad class for a specific triad
    
  }
  # print(t2)
  df <- merge.data.frame((t1),subset(t2,select=c(name, stamp, t2_ij:t2_kj, typeT2)), by = "name")
  
  for(i in 1:nrow(df)){
    # print(i)
    
    df$equal[i] <- sum(df[i, 3:8] != df[i, 11:16]) <= 2
    # print(Triad_change$equal[i])  
    
  }
  
  print(as.data.frame(df[which(df$equal == FALSE),c("name", "typeT1", "typeT2")]))
  # filt <- df[df$equal == TRUE,]
  test_tab <<- reshape2::melt(table(df$typeT1, df$typeT2, dnn = c("Timepoint 1", "Timepoint 2")))
  print(test_tab)
  test <<- df
  # test_f <<- filt
}
```

```{r}

# no_cores <- detectCores() - 1
# mycl <- makeCluster(rep("localhost", no_cores))
# clusterEvalQ(mycl, library(RsienaTwoStep))
# registerDoParallel(mycl)
# # stopCluster(mycl)

triad.evolution3(s501[1:15,1:15],s502[1:15,1:15])


```

```{r}

```

